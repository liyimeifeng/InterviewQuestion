JAVA面试题
---------------------------------------

1.JDK和JRE的区别？
	JRE：Java RunTime Environment
	JDK: Java Development Kit
	JRE: 包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户运行的。
	JDK：java开发工具包，是程序员使用java语言编写 java程序所需要的开发工具包，是提供给程序员用的，JDK包含JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm
	等工具软件，还包含了java程序编写所需的文档和demo例子。
	运行java程序，只安装JRE，编写就用JDK，但是根据系统和公司不同，推荐使用sun公司的。

2.为什么java被称为是“平台无关的编程语言”？
	java虚拟机是一个可以执行java字节码的虚拟机进程。java源文件被编译成java虚拟机执行的字节码文件。
	Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。
	因为java虚拟机知道底层硬件平台的指令长度和其他特性。
	
3.java中基本数据类型有哪些？数据长度分别是多少？
	byte 2的8次方
	short 2的16次方
	int 2的32次方
	long 2的64次方
	float 2的32次方单精度小数
	double 2的64次方双精度小数
	boolean true，false
	char 一个字符
	
4.什么是值传递和引用传递？
	值传递仅仅传递的是值，引用传递传递的是内存地址，修改会改变内存地址对应储存的值
	
5.进程与线程的区别？
	一个进程中可以包含多个线程。
	进程是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态的概念，竞争计算机系统资源的基本单位。
	线程是进程的一部分，一个没有线程的进程可以看做是一个单线程进程。
	
6.请描述一些线程生命周期
	线程有五种状态（也有说六种状态）。各种状态间的切换是通过不同方法的调用实现的。
	线程被创建（创建Thread类实例或者Thread类子类实例）
	start（）后  
       线程运行--调用start（）后开启的线程不一定立即就会被运行，即不一定立即调用run（）方法。因为cpu在不同线程间要进行快速的切换。
       线程被开启后排队等待cpu执行的状态，我们称之为“临时状态或者阻塞状态”。此时，线程拥有执行资格，但没有执行权。
       线程调用start（）开启后，可能处于两种状态——运行状态和临时状态（阻塞状态）
       运行状态中的线程调用sleep（）或者wait（）方法，线程就会处于“冻结状态”。
       注意：冻结状态包含“睡眠状态”和“等待状态”；
       此时的线程仍然“活着”，即进程依然存在。
       处于“冻结状态”的线程没有cpu的执行权，不能直接就到运行状态，要先去排队，获得执行资格。即进入临时状态，再到运行状态。
       运行状态到“消亡状态”，线程调用stop（），或者run（）执行完毕，正常结束。

	
7.同步方法和同步代码块的区别？
	同步方法是使用synchronized关键字来修饰整个方法，在使用的时候需要获取锁对象
	同步代码块是由synchronize关键字修饰的语句块，被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。
	同步是一种消耗很大的操作，尽量少包裹代码
	还有一种volatile特殊域变量，提供了一种免锁机制。

8. 什么是死锁(deadlock)？
	所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
	此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，
	使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。
	
	虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。
		1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
		2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
		3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
		4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
		
	在系统中已经出现死锁后，应该及时检测到死锁的发生，并采取适当的措施来解除死锁。目前处理死锁的方法可归结为以下四种：
		1) 预防死锁。
			这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。
			但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。
		2) 避免死锁。
			该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。
		3)检测死锁。
			这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。
			但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。
		4)解除死锁。
			这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，
			再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。
			

9. Java集合类框架的基本接口有哪些？
	1) Collection
	一组"对立"的元素，通常这些元素都服从某种规则
 　　1.1) List必须保持元素特定的顺序
			ArrayList
			LinkedList
 　　1.2) Set不能有重复元素(不能使用==来判断，需使用equals()方法)
			HashSet
			LinkedHashSet 适合遍历
			SortedSet此接口主要用于排序操作，即实现此接口的子类都属于排序的子类，例如TreeSet
 　　1.3) Queue保持一个队列(先进先出)的顺序
			Queue用于模拟"队列"这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。
	2) Map
	一组成对的"键值对"对象
	有hashMap，LinkedHashMap，TreeMap
	3)
	iterator遍历
	
10. Iterator和ListIterator的区别是什么？
	1、Iterator是ListIterator的父接口。
	2、Iterator是单列集合(Collection)公共取出容器中元素的方式。
		对于List，Set都通用。
		而ListIterator是List集合的特有取出元素方式。
	3、Iterator中具备的功能只有hashNext(),next()，remove();
		ListIterator中具备着对被遍历的元素进行增删改查的方法，可以对元素进行逆向遍历。
		之所以如此，是因为ListIterator遍历的元素所在的容器都有索引。
		

11. Java中的HashMap的工作原理是什么？
	HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
	当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。
	
12. HashMap和Hashtable有什么区别？
	1.Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现。
	2.也许最重要的不同是Hashtable的方法是同步的，而HashMap的方法不是。这就意味着，虽然你可以不用采取任何特殊的行为就可以在一个多线程的应用程序中用一个Hashtable，但你必须同样地为一个HashMap提供外同步。
	3.只有HashMap可以让你将空值作为一个表的条目的key或value。
	
13.hashCode()和equals()方法的重要性体现在什么地方？
	Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。
	如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。
	而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。
	
14.ArrayList和LinkedList有什么区别？
	ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。
	LinkedList implements List<E>, Deque<E>。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，
即能将LinkedList当作双端队列使用。自然也可以被当作"栈来使用"
	
15.Comparable和Comparator接口是干什么的？列出它们的区别。
	Java提供了只包含一个compareTo()方法的Comparable接口。
		这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
	Java提供了包含compare()和equals()两个方法的Comparator接口。
		compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。
		equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。
		只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true
		
16. HashSet和TreeSet有什么区别？
	1.HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。
	当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。
    值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法。
	2.TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。
	
17. Java中垃圾回收有什么目的？什么时候进行垃圾回收？
	垃圾回收器的作用是查找和回收（清理）无用的对象。以便让JVM更有效的使用内存。
	垃圾回收器的运行时间是不确定的，由JVM决定，在运行时是间歇执行的。虽然可以通过System.gc（）来强制回收垃圾，
但是这个命令下达后无法保证JVM会立即响应执行，但经验表明，下达命令后，会在短期内执行的请求。JVM通常会感到内存紧缺时候去执行垃圾回收操作。
	垃圾回收过于频繁会导致性能下降，过于稀疏会导致内存紧缺。这个JVM会将其控制到最好，不用程序员担心。
	
18.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?
	Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存储对象实例，几乎所有的对象实例都在这里分配内存。
	
19. 面向对象的特征有哪些方面？
	继承 封装 多态 抽象
	
20. 访问修饰符public,private,protected,以及不写（默认）时的区别？
	public是可以被所有的类访问
	protected可以在本包和其他包中的子类访问
	default可以在本包中访问
	private只可以在本类中访问
	
21.string是最基本的数据类型吗？
	不是
	
22.float f = 3.4正确吗？
	不正确，3.4默认是double类型的，从大范围到小范围转换的时候需要强制类型转换，或者直接在3.4后面加上一个f。
	
23. short s1 = 1; s1 = s1 + 1;有错吗?——有错，因为类型不匹配:不能从int转换为short型。可更改为s1 = (short) (s1 + 1);
      short s1 = 1; s1 += 1;有错吗？ ——没有错。
	  
————
24. 解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。 
     答：栈（stack）：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；
	       堆（heap）：通过new关键字和构造器创建的对象放在堆空间；
		   静态区（static area）：程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在静态区中。
		   栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。
		   补充：较新版本的Java（从Java 6的某个更新开始）中使用了一项叫"逃逸分析"的技术，可以将一些局部对象放在栈上以提升对象的操作性能。

————
25. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ 
     答：在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型；
	       由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的；
		   显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。

————
26. String和StringBuilder、StringBuffer的区别？ 
     答：三者都是用来代表字符串。
	      （1）可变不可变：String类是不可变类，任何对String的改变都 会引发新的String对象的生成；
		                             StringBuffer与StringBuilder，他们是字符串变量，是可改变的对象；
		  （2）执行速度方面：StringBuilder >  StringBuffer 
		  （3）是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。
		                                    StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的；
                                             StringBuilder并没有对方法进行加同步锁，所以是非线程安全的；
			StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。
		总结：如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。

————
27. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 
     答：方法的重载和重写都是实现多态的方式，区别在于重载实现的是编译时的多态性，而重写实现的是运行时的多态性。
	        重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重载对返回类型没有特殊的要求。
			重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）

————
28. 描述一下JVM加载class文件的原理机制？ 
     答：JVM（Java Virtual Machine ）——JAVA虚拟机
	       JVM中类的装载是由ClassLoader(类装载器)和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。
		   在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，其中链接又可以分成校验、准备、解析；
		                   装载：查找和导入类或接口的二进制数据； 
                           链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； 
                           校验：检查导入类或接口的二进制数据的正确性； 
                           准备：给类的静态变量分配并初始化存储空间； 
                           解析：将符号引用转成直接引用；
                           初始化：激活类的静态变量,初始化Java代码和静态Java代码块
	      1、Java中的所有类，必须被装载到jvm中才能运行，这个装载工作是由jvm中的类装载器完成的，类装载器所做的工作实质是把类文件从硬盘读取到内存中；
		  2、Java中的类大致分为三种：（1）系统类；（2）扩展类；（3）由程序员自定义的类
		  3、类装载方式有两种：（1）隐式装载：程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
		                                    （2）显示装载：通过class.forname()等方法，显式加载需要的类
         4.类加载的动态性体现： 一个应用程序总是由n多个类组成，Java程序启动时，并不是一次把所有的类全部加载后再运行，它总是先把保证程序运行的基础类一次性加载到jvm中，
		                                     其它类等到jvm用到的时候再加载，这样的好处是节省了内存的开销，因为java最早就是为嵌入式系统而设计的，内存宝贵，
											 这是一种可以理解的机制，而用到时再加载这也是java动态性的一种体现 
         
————
29. char 型变量中能不能存贮一个中文汉字，为什么？ 
     答：能。因为java采用unicode，2个字节（16位）来表示一个字符， 无论是汉字还是数字字母，或其他语言。char 在java中是2个字节。所以可以存储中文

————
30. 抽象类（abstract class）和接口（interface）有什么异同？ 
     答：如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。
	      （1）抽象类和接口一样，都用来声明一个新的类型。并且作为一个类型的等级结构的起点。
		  （2）语法层次的区别：
	              1、抽象类可以有构造方法，接口不允许
                  2、抽象类可以有普通成员变量，接口中没有
                  3、抽象类可以有静态成员变量，其访问类型可以任意；接口中定义的变量实际只能是常量
                  4、抽象类可以有非抽象的普通方法，接口中的方法必须是抽象的
                  5、抽象类中的抽象方法的访问类型可以是public,protected，接口中的抽象方法只能是public
                  6、抽象类中可以有静态方法，接口中不允许
		          7、一个类只能继承一个抽象类，而一个类却可以实现多个接口。
		          8、一个接口也可以实现另一个接口，而实现类则必须实现全部接口中的方法；
          （3）设计层次的区别：
		          1、抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
		          2、设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。
          
————
31. 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？ 
     答：嵌套类可以分为两种，静态的和非静态的，即静态嵌套类和非静态嵌套类。非静态嵌套类又叫做内部类（Inner Class）。
	       我们通常所说的静态内部类其实是不严格的，严格的说应该叫做静态嵌套类(Static Nested Class)。
		   静态嵌套类：与外部类相关联，而不是与外部类对象相关联； 是依附于外部类而非外部类对象的，所以不同的外部类对象共享一个静态嵌套类。
		   内部类：是和外部类对象关联的，不能定义任何静态成员。
		   内部类和静态嵌套类的最大区别在于是否能够访问外部类成员。
		   
————
32. 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？ 
     答：abstract：用来声明抽象方法，抽象方法没有方法体，不能被直接调用，必须在子类overriding后才能使用；
	        static：用来声明静态方法，静态方法可以被类及其对象调用；
			native：用来声明本地方法，该方法的实现由非Java 语言实现，比如C。一般用于java与外环境交互，或与操作系统交互；
			synchronized：用于防止多个线程同时调用一个对象的该方法，与static连用可防止多个线程同时调用一个类的该方法；
			——static与abstract不能同时使用；——native 可以与所有其它的java 标识符连用，但是abstract除外；——abstract与synchronized不能同时使用
			
————
33. GC是什么？为什么要有GC？ 
     答：GC是垃圾回收的意思（gabage collection），用来释放内存中的资源的。
	       因为内存处理器是编程人员容易出现问题的地方，忘记或者错误的内存回收导致程序或者系统的不稳定甚至崩溃。
		   Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

————
34. 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 
     答：接口可以继承接口；抽象类可以实现接口；抽象类是可以继承具体类；

————
35. 一个".java"源文件中是否可以包含多个类（不是内部类）？有什么限制？ 
     答：可以包含多个类。只允许有一个公共类，且公共类名与Java源文件名相同。
	 
————
36. Error和Exception有什么区别？ 
     答：Error（错误）表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。
	                 比如：内存资源不足等。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由Java虚拟机抛出的。
		    Exception（违例）表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。
			Exception又分为运行时异常，受检查异常。
			                运行时异常，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止程序，因此，编译器不检查这些异常。
							受检查异常，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理）， 所以称之为受检查异常。

	
37. try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 
	会执行，在return前执行。系统会把return中返回值暂存在堆中，然后执行finally（）语句，最后执行return语句。
	
38. Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
	通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
	try 用来指定一块预防所有“异常”的程序；
	catch 子句紧跟在 try 块后面，用来指定你想要捕捉的“异常”的类型；
	throw 语句用来明确地抛出一个“异常”；
	throws 用来标明一个成员函数可能抛出的各种“异常”；
	Finally 为确保一段代码不管发生什么“异常”都被执行一段代码；

39. 运行时异常与受检异常有何异同？ 
	受检查异常表示程序可以处理的异常，如果抛出异常的方法本身不能处理它，那么方法调用者应该去处理它，从而使程序恢复运行，
	不至于终止程序。JAVA编译器强制要求我们必需对出现的这些异常进行try catch。
	运行时异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误操作。一旦出现了错误操作，建议终止程序，
	因此Java编译器不检查这种异常。包括错误的类型转换、数组越界访问和试图访问空指针等等。
	
40. 列出一些你常见的运行时异常？ 
	ClassCastException,
	IndexOutOfBoundsException, NullPointerException,
	

43. Collection和Collections的区别？ 
	Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
	Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
	
44. 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 
	不能，Java中的每个对象都有一个锁（lock）或者叫做监视器（monitor），当访问某个对象的synchronized方法时，表示的将该对象上锁，
	此时其他任何线程都无法再去访问该synchronized方法了，直到之前的那个线程执行方法完毕后（或者是抛出了异常），才将该对象的锁释放掉，
	其他线程才有可能再去访问该synchronized方法。
	
45. Java中如何实现序列化，有什么意义？ 
	Java对象的序列化有两种方式：一种是相应的对象实现了序列化接口Serializable，实现序列化的第二种方式为实现接口Externalizable。
	有的时候我们想要把一个Java对象变成字节流的形式传出去，有的时候我们想要从一个字节流中恢复一个Java对象。例如，有的时候我们想要
	把一个Java对象写入到硬盘或者传输到网路上面的其它计算机，这时我们就需要自己去通过java把相应的对象写成转换成字节流。
	
46. 简述一下你了解的设计模式。
	创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
	结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
	行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
	除了以上还有并发型模式和线程池模式。
	具体模式情况请访问如下连接：http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html
	
47. 简述常见的排序算法有哪些，基本思想是什么？算法复杂度是多少？
	冒泡排序：依次比较相邻的两个数，将小数放在前面，大数放在后面。这样小数像气泡一样不断上升，大数下沉。平均情况下时间复杂度为O(n^2)
	快速排序：基本思想是通过一趟排序将序列划分为两部分，其中一部分所有的数据比另一部分所有的数据都要小。然后对这两部分分别进行快速排序，
	整个排序是一个递归调用的过程，最终实现整个序列有序。平均时间复杂度O(nlogn)。
	选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 
	选择排序是不稳定的排序方法。平均时间复杂度为O(N^2)。
	详细说明请移步：http://blog.csdn.net/zaishaoyi/article/details/47726665
	
48. 简述常见的搜索算法有哪些，基本思想是什么？算法复杂度是多少？
	二分查找法：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，
	再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。期望时间复杂度为O(log2n).
	顺序查找：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；
	若扫描结束仍没有找到关键字等于k的结点，表示查找失败。顺序查找的时间复杂度为O(n)。
	二叉树查找：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 
	这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。时间复杂度为O(logn)
	更多算法移步：http://sanwen8.cn/p/142Wbu5.html
49. 简述==与equals的区别
	java中equals和==的区别 值类型是存储在内存中的堆栈（简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。
	==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。
	equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。
	
50. 简述TCP协议的三次握手流程
	1.客户端向服务器发送一个SYN置位的TCP报文，其中包含连接的初始序列号x和一个窗口大小（表示客户端上用来存储从服务器发送来的传入段的缓冲区的大小）。
	2.服务器收到客户端发送过来的SYN报文后，向客户端发送一个SYN和ACK都置位的TCP报文，其中包含它选择的初始序列号y、对客户端的序列号的确认x+1和一个窗口大小
	（表示服务器上用来存储从客户端发送来的传入段的缓冲区的大小）。
	3.客户端接收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号y+1和序号x+1的ACK报文，一个标准的TCP连接完成。
	
	
	
Android面试题
------------------------------------
一. Android中布局方式有哪些，分别有什么区别？
	1.FrameLayout:children按照从左上开始的顺序排列，主要用于tabed view或者图片切换功能；最简单的布局模型，在这种布局下每个添加的子控件都被放在布局的左上角，并覆盖在前一子控件的上层。
	2.线性布局（LinearLayout）:children排列成一行多列或者一列多行的形式，应该是应用程序中最常用的布局方式，它提供了控件水平或者垂直排列的模型，同时我们可通过设置子控件的weight布局参数控制各个控件在布局中的相对大小。
	3.相对布局（RelativeLayout）:children是相互之间相关位置或者和他们的parent位置相关，参照控件可以是父控件，也可以是其他子控件，但被参照的控件必须要在参照它的控件之前定义。相对布局模型所涉及的属性设置比较多，但并不复杂。
	4.TableLayout:children按照行列的排序，类似于html的table；模型以行列的形式管理子控件，每一行为一个TableRow的对象，也可为一个View的对象。TableRow可添加子控件，每添加一个子控件为一列。
	5.绝对布局（AbsoluteLayout）的子控件需要指定相对于此坐标布局的横、纵坐标值，否则将会像FrameLayout那样被排在左上角。手机应用需要适用于不同的屏幕大小，而这种布局模型不能自适应屏幕尺寸大小，所以应用得相当少。

二. 简述Activity的生命周期，并描述其方法在什么时候会被调用。
	1. void onCreate(Bundle savedInstanceState) 
	当Activity被第首次加载时执行。我们新启动一个程序的时候其主窗体的onCreate事件就会被执行。如果Activity被销毁后（onDestroy后），再重新加载进Task时，其onCreate事件也会被重新执行。
	2. void onStart()   activity变为在屏幕上对用户可见时调用。
	onCreate事件之后执行。或者当前窗体被交换到后台后，在用户重新查看窗体前已经过去了一段时间，窗体已经执行了onStop事件，但是窗体和其所在进程并没有被销毁，用户再次重新查看窗体时会执行onRestart事件，之后会跳过onCreate事件，直接执行窗体的onStart事件。 

	3. void onResume()   activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）。
	onStart事件之后执行。或者当前窗体被交换到后台后，在用户重新查看窗体时，窗体还没有被销毁，也没有执行过onStop事件（窗体还继续存在于Task中），则会跳过窗体的onCreate和onStart事件，直接执行onResume事件。 

	4. void onPause()   activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的，也是保护现场，压栈吧！
	窗体被交换到后台时执行。 

	5. void onStop()    activity被停止并转为不可见阶段及后续的生命周期事件时调用。
	onPause事件之后执行。如果一段时间内用户还没有重新查看该窗体，则该窗体的onStop事件将会被执行；或者用户直接按了Back键，将该窗体从当前Task中移除，也会执行该窗体的onStop事件。 

	6. void onRestart()   重新启动activity时调用。该活动仍在栈中，而不是启动新的活动。
	onStop事件执行后，如果窗体和其所在的进程没有被系统销毁，此时用户又重新查看该窗体，则会执行窗体的onRestart事件，onRestart事件后会跳过窗体的onCreate事件直接执行onStart事件。 

	7. void onDestroy()   activity被完全从系统内存中移除时调用，该方法被调用可能是因为有人直接调用onFinish()方法或者系统决定停止该活动以释放资源！
	Activity被销毁的时候执行。在窗体的onStop事件之后，如果没有再次查看该窗体，Activity则会被销毁。 
三 . Acitivity在意外终止时如何保持状态
	通过调用onSavaInstanceState方法保持activity的状态。

四：简述自定义布局和自定义视图的实现方式有哪些
	（一）组合控件
	　　组合控件就是将一些小的控件组合起来形成一个新的控件，这些小的控件多是系统自带的控件。
	（二）自绘控件
	　　自绘控件的内容都是自己绘制出来的，在View的onDraw方法中完成绘制。
	（三）继承控件
	　　就是继承已有的控件，创建新控件，保留继承的父控件的特性，并且还可以引入新特性。

五. 简述如何实现屏幕适配
	（1）、支持不同尺寸的设备
	1 使用 "wrap_content" 和 "match_parent"
	2 使用相对布局
	3 使用尺寸限定符
	4 使用宽度限定符 (sw600dp 或者 w600dp)
	5 使用方向限定符
	6 使用Nine-patch 图片
	7 使用PercentFrameLayout

	（2）、支持不同密度的设备
	1 使用使用设备独立像素（dp 或sp）
	2 提供可选择性的位图
	3 、使用流式布局

六.什么是ANR错误，如何产生，怎么避免？
	在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。
	用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。
	解决方案：
	将所有耗时操作，比如访问网络，Socket 通信，查询大量 SQL 语句，复杂逻辑计算等都放在子线程中去，然后
	通过 handler.sendMessage、runonUITread、AsyncTask 等方式更新 UI。无论如何都要确保用户界面操作的流畅度。如果耗时操作需要让用户等待，那么可以在界面上显示进度条。

七、什么情况下会产生OOM异常，如何解决？
	产生原因：android系统的app的每个进程或者每个虚拟机有个最大内存限制，如果申请的内存资源超过这个限制，系统就会抛出OOM错误。
	（1）. 常见避免OOM的几个注意点：
	1 适当调整图像大小 。因为手机屏幕尺寸有限，分配给图像的显示区域有限，尤其对于超大图片，加载自网络或者sd卡，图片文件提及达到几M或者十几个M的：
		加载到内存前，先算出该bitmap的大小，然后通过适当调节采样率使得加载的图片刚好，或稍大捷克在手机屏幕上显示就满意了：
	2 图像缓存 。在listview或Gallery等控件中一次性加载大量图片时，只加载屏幕显示的资源，尚未显示的不加载，移出屏幕的资源及时释放，
		采用强引用＋软引用2级缓存，提高加载性能。缓存图像到内存，采用软引用缓存到内存，而不是在每次使用的时候都从新加载到内存。
	3 采用低内存占用量的编码方式 。比如Bitmap.Config.ARGB_4444比Bitmap.Config.ARGB_8888更省内存。
	4 及时回收图像 。如果引用了大量的Bitmap对象，而应用又不需要同时显示所有图片。可以将暂时不用到的Bitmap对象及时回收掉。对于一些明确直到图片使用情况的场景可以主动recycle回收
		App的启动splash画面上的图片资源，使用完就recycle。对于帧动画，可以加载一张，画一张，释放一张。
	5 不要在循环中创建过多的本地变量 。慎用static，用static来修饰成员变量时，该变量就属于该类，而不是该类实例，它的生命周期是很长的。如果用它来引用一些内存占用太多的实例，这时候就要谨慎对待了。
	6 自定义堆内存分配大小 。优化Dalvik虚拟机的堆内存分配。

	（2）App使用图片时避免OOM的几种方式：

	1  直接null或recycle
		对于app里使用的大量图片，采用方式：使用时加载，不显示时直接置null或recycle。
	2 简单通过SoftReference引用方式管理图片资源，建个SoftReference的hashmap使用图片时先查询这个hashmap是否有softreference，
		softreference里的图片是否为空，如果为空就加载图片到softreference并加入hashmap。无需再代码里显式的处理图片的回收与释放，gc会自动处理资源的释放。

	3 强引用＋软引用二级缓存
		Android示范程序ImageDownloader.java, 使用了一个二级缓存机制。就是有一个数据结构直接持有解码成功的Bitmap对象引用，
		同时使用一个二级缓存数据结构保持淘汰的Bitmap的softreference对象，由于softreference对象的特殊性，系统会再需要内存的时候首先将softreference持有的对象释放掉，
		也就是说当vm发现可用的内存较少需要出发gc的时候，二级缓存中的bitmap对象将被回收，而持有一级缓存的bitmap对象用于显示。
		其实这个解决方案最为关键的一点是使用了一个比较合适的数据结构，那就是LinkedHashMap类型来进行一级缓存Bitmap的容器。
		由于LinkeHashMap的特殊性，我们可以控制其内存存储对象的个数并且将不在使用的对象从容器中移除，放到softreference二级缓存里，我们可以在一级缓存中一致保存最近被访问到的bitmap对象，
		而已经被访问过的图片在LinkedHashMap的容量超过我们预设值时将会把容器中存在的时间最长的对象移除，这个时候我么可以将被移除的LinkedHashMap中的放到二级缓存容器，
		而二级缓存中的对象管理就交给系统来做了，当系统需要gc时就会首先回收二级缓存容器的Bitmap对象了。
		在获取图片对象时候先从一级缓存容器中查找，如果有对应对象并可用直接返回，如果没有的话从二级缓存中查找对应的SoftReference, 
		判断SoftReference对象持有的Bitmap是否可用，可用直接返回，否则返回空。如果二级缓存都找不到图片，那就直接加载图片资源。
		
	4， LruCache  + sd的缓存方式

八.简述线程通信的基本原理
	1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，所以MessageQueue在一个线程中只会存在一个。
	2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。
	3、Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue相关联。
	4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。
	5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。

九 简述Handler、Looper、Message、MessageQueue之间的关系
	1、首先Looper.prepare()在本线程中保存一个Looper实例，然后该实例中保存一个MessageQueue对象；因为Looper.prepare()在一个线程中只能调用一次，
所以MessageQueue在一个线程中只会存在一个。
	2、Looper.loop()会让当前线程进入一个无限循环，不端从MessageQueue的实例中读取消息，然后回调msg.target.dispatchMessage(msg)方法。
	3、Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue相关联。
	4、Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。
	5、在构造Handler实例时，我们会重写handleMessage方法，也就是msg.target.dispatchMessage(msg)最终调用的方法。

十 简述服务跟线程的区别
      Thread：Thread 是程序执行的最小单元，可以用 Thread 来执行一些异步的操作。
      Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。
如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。
      Thread 的运行是独立的，也就是说当一个 Activity 被 finish 之后，如果没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，
Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，
	  不再持有该 Thread 的引用，也就是不能再控制该Thread。另一方面，没有办法在不同的 Activity 中对同一 Thread 进行控制。
十一. 启动服务的方式有哪些，有什么区别？
	1、onStartCommand ()   
	如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()。
	服务停止的时候调用 onDestory()。服务只会被停止一次。
	特点：一旦服务开启跟调用者(开启者)就没有任何关系了。
		开启者退出了，开启者挂了，服务还在后台长期的运行。
		开启者不能调用服务里面的方法。
	2.onBind()
	绑定服务不会调用onstart()或者onstartcommand()方法
	特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。
		绑定者可以调用服务里面的方法。

十二 简述Android中进程回收的级别
	1.前台进程( FOREGROUND_APP)
	2.可视进程(VISIBLE_APP )
	3. 次要服务进程(SECONDARY_SERVER )
	4.后台进程 (HIDDEN_APP)
	5.内容供应节点(CONTENT_PROVIDER)
	6.空进程(EMPTY_APP)

十三. 简述Android中进程间通信的方式是？
	
	//Content Provider 内部实现了进程间的通信，但不是说他自己能够实现进程间的通信。
	广播（Broadcast） 
	利用AIDL Service实现跨进程通信，系统IPC方式。
	SOCKET通信

十四  如何避免服务被系统回收？
	1.把service写成系统服务，将不会被回收（）： 
		在Manifest.xml文件中设置persistent属性为true，则可使该服务免受out-of-memory killer的影响。但是这种做法一定要谨慎，系统服务太多将严重影响系统的整体运行效率。 
	2.提高service的优先级（）： 
		设置android:priority="1000" 
	3.将服务写成前台服务foreground service（）： 
		重写onStartCommand方法，使用StartForeground(int,Notification)方法来启动service。 
		注：前台服务会在状态栏显示一个通知，最典型的应用就是音乐播放器，只要在播放状态下，就算休眠也不会被杀，如果不想显示通知，只要把参数里的int设为0即可。 
	4.利用ANDROID的系统广播检查Service的运行状态，如果被杀掉，就再起来（未实践）： 
		利用的系统广播是Intent.ACTION_TIME_TICK，这个广播每分钟发送一次，我们可以每分钟检查一次Service的运行状态，如果已经被结束了，就重新启动Service。  

十五 如何将一个Android组建放置在独立进程中运行
	在manifests中声明process属性.

十六 简述广播的分类及其区别
	答案一：
		1、常驻型广播
		常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，
		他的注册方式就是在你的应用程序中的AndroidManifast.xml进行注册。通常说这种方式是静态注册，
		静态注册：定义一个广播接收器继承BroadcastReceiver，android不能自动销毁广播接收器，也就是说当应用程序关闭后，还是会接收广播。
		2.非常驻型广播
		当应用程序结束了，广播自然就没有了，比如你在activity中的onCreate或者onResume中注册广播接收器
		在onDestory中卸载广播接收器。这样你的广播接收器就一个非常驻型的了。这种也叫动态注册。
		动态注册：在代码中通过registerReceiver()手工注册.当程序关闭时,该接收器也会随之销毁。当然，也可手工调用unregisterReceiver()进行销毁。
		
	答案二：
		1、普通广播，也称为有序广播（Normalbroadcasts）
		是完全异步的，可以在同一时刻(逻辑上)被所有广播接收者接收到，消息传递的效率比较高，
		但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播intent的传播。								
		Context.sendBroadcast()发送的是普通广播，所有订阅者都有机会获得并进行处理。
		2、有序广播(Ordered broadcasts)		Context.sendOrderedBroadcast()
		发送的是有序广播，系统会根据接收者声明的优先级按顺序逐个执行接收者，
		前面的接收者有权终止广播（通过调用BroadcastReceiver.abortBroadcast()），
		如果广播被前面的接收者终止，后面的接收者就再也无法获取到广播。
		对于有序广播，前面的接收者可以将处理结果存进广播Intent，然后传给下一个接收者。
		
十七  简述普通广播和本地广播的区别
	BroadcastReceiver是针对应用间、应用与系统间、应用内部进行通信的一种方式
	LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到
	
十八 如何在有序广播中传递数据或终止广播
	有序广播是按照接收者声明的优先级别(声明在intent-filter元素的android:priority)属性中，数越大优先级别越高，取值范围：-1000到1000。
	也可以调用IntentFilter对象的setPriority()进行设置），被接收者依次接收广播。
	如：A的级别高于B,B的级别高于C,那么，广播先传A，在传给B，最后传给C，A得到广播后，可以往广播里存入数据，
	当广播传给B时，B可以从广播中得到A存入的数据。调用BroadcastReceiver.abortBroadcast()既可以终止广播
	
十九 Android中数据存储的方式有哪些，分别适用于什么场景
	第一种： 使用SharedPreferences存储数据
	　　适用范围：保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口 令密码等。
		这类存储主要适用于存储信息量小的操作。具有操作和存储简便，代码简单的特点
	第二种： 文件存储数据（File I/O流）
		这类一般都是存成文件的形式。适用于存储信息量大，操作相对复杂些。
	　　可以在设备本身的存储设备或者外接的存储设备中创建用于保存数据的文件。同样在默认的状态下，文件是不能在不同的程序间共享。
	　　写文件：调用Context.openFileOutput()方法根据指定的路径和文件名来创建文件，这个方法会返回一个FileOutputStream对象。
	　　读取文件：调用Context.openFileInput()方法通过制定的路径和文件名来返回一个标准的Java FileInputStream对象。
	第三种：SQLite存储数据
		适用于存储信息量适中，这类存储在查询的时候比较方便。而且能很好的支持SQL语句。
	　　SQLite Database数据库。Android对数据库的支持很好，它本身集成了SQLite数据库，每个应用都可以方便的使用它，
		或者更确切的说，Android完全依赖于SQLite数据库，它所有的系统数据和用到的结构化数据都存储在数据库中。 
		它具有以下优点： a. 效率出众，这是无可否认的 b. 十分适合存储结构化数据 c. 方便在不同的Activity，甚至不同的应用之间传递数据。
	第四种：ContentProvider
	　　存储例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个ContentProvider都会对外提供一个公共的URI（包装成Uri对象），
		如果应用程序有数据需要共享时，就需要使用ContentProvider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。
	第五种：网络存储数据
	
二十 简述SQLite跟服务器数据的区别
	
二十一 Android中数据库升级时如何处理？
	
	
二十二 SQLite数据库是否可以并发读写？
	读操作之间能够并发执行，读操作要能够共享，写操作要互斥，读写之间也要互斥。
	
二十三 intentServer与Service的区别是什么？
	Service主要用于后台服务 当应用程序被挂到后台的时候，为了保证应用某些组件仍然可以工作而引入了Service这个概念，
	Service不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的，不建议在Service中编写耗时的逻辑和操作，否则会引起ANR。
	这时需要引入IntentService，IntentService是继承Service的，它包含了Service的全部特性，也包含service的生命周期，
	与service不同的是，IntentService在执行onCreate操作的时候，内部开了一个线程，去执行你的耗时操作。
	service提供了一个方法 onStartCommand 当service启动或被调用时候会执行这个方法。
	
	IntentService:异步处理服务，新开一个线程：handlerThread在线程中发消息，然后接受处理完成后，会清理线程，并且关掉服务。
		IntentService有以下特点：
		（1）  它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。
		（2）  创建了一个工作队列，来逐个发送intent给onHandleIntent()。
		（3）  不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。
		（4）  默认实现的onBind()返回null
		（5）  默认实现的onStartCommand()的目的是将intent插入到工作队列中。
		
二十四  Activity、Window、View三者的差别，fragment的特点？
	个人理解，Activity是框架，View是页面布局整体呈现，Fragment是依附于Activity的碎片化界面，可以加载可以被替换。
	
二十五 描述一次网络请求的流程
	创建URL对象——》通过url获取连接——》设置请求方式——》设置连接超时——》获取响应码——》读取网页内容(字符串流)
	
二十六  Handler、Thread和HandlerThread的差别
	Handler主要接受子线程Thread发送的数据, 并用此数据配合主线程更新UI。HandlerThread就是可以处理消息循环的线程，他是一个拥有Looper的线程，可以处理消息循环。
	
二十七 Activity launchMode 值分别有哪些，有什么区别？
	1.standard
  ·		标准模式，每次激活Activity时均在当前任务栈中创建新的实例
	2.·singleTop
    ·	位于栈顶时唯一，如果当前Activity已位于当前任务栈的栈顶，则再次激活该Activity也不会创建新的实例
	3.·singleTask
	（1）独立于任务栈，如果该singleTaskActivity的实例不存在，则激活时会创建并获得栈顶位置。
	（2）如果singleTaskActivity的实例已经存在，激活时不会创建新的singTaskActivity实例，且原来已经存在的singTaskActivity上方的Activity均出栈，原来的这个singTaskActivity获得栈顶位置。
	singTaskActivity要么不存在要么只有一个实例，激活时，肯定在栈顶位置，前面若有Activity时会被“挤”出站（被销毁）
	4.·singleInstance
	·实例唯一，无论哪个Task,共享同一个Activity的实例。
	·该Activity有独立的Task（独占一个Task），且在Task中唯一，由该Activity激活的其它Activity归属于其它Task，由被配置为singleInstance的Activity激活的其它Activity，会尝试放在
	存在“亲属”关系的Task中，如果没有匹配的Task存在，则会创建新的Task存放被激活的Activity。

二十八  touch 事件传递流程
	主要用到三个方法。负责处理触摸事件的派发dispatchTouchEvent()——》默认返回false表示不拦截事件，
	当返回true时表示拦截了事件，即自己处理消费onInterceptTouchEvent()——》处理触摸事件的按下移动和弹起的操作，
	当返回为true时表示消费了这个事件，false则不消费，即返回上一层处理。onTouchEvent()。
	
二十九 简述view绘制流程
	Measure过程——》layout过程——》draw过程
	
三十 invalidate()和postInvalidate()的区别及使用
	区别：
		（1）前者在UI线程自身中使用，而后者在非UI线程中使用。
		（2）Android提供了Invalidate方法实现界面刷新，但是Invalidate不能直接在线程中调用，
			因为他是违背了单线程模型：Android UI操作并不是线程安全的，并且这些操作必须在UI线程中调用。 
		使用：
		（1）利用invalidate()刷新界面 
			实例化一个Handler对象，并重写handleMessage方法调用invalidate()实现界面刷新;
			而在线程中通过sendMessage发送界面更新消息。
		（2）使用postInvalidate()刷新界面 
			使用postInvalidate则比较简单，不需要handler，直接在线程中调用postInvalidate即可。 
			列如: // 使用postInvalidate可以直接在线程中更新界面   
			
三十一 Android中动画实现的方式有哪些，分别基于什么原理？
	(1)、Animation类
		原理：
			每个动画都重载了父类的applyTransformation方法这个方法的主要作用是把一些属性组装成一个Transformation类,这个方法会被父类的getTransformation方法调用。
			另外每个动画还有个initialize方法,完成初始化工作,动画开始前的一些准备工作。
		(2)、Interpolator类
		原理：
			定义动画执行过程一些加速度减速度,为了我们后面Transformation来服务的。
		3、Transformation类
		原理：
			Transformation记录了仿射矩阵Matrix,动画每触发一次，会对原来的矩阵做一次运算,View的Bitmap与这个矩阵相乘就可以实现相应的操作(旋转、平移、缩放等)。
			
三十二 Android View刷新机制
	(1)在Android的布局体系中，父View负责刷新、布局显示子View；而当子View需要刷新时，则是通知父View来完成。
	(2)子View调用invalidate时，首先找到自己父View(View的成员变量mParent记录自己的父View)，然后将AttachInfo中保存的信息告诉父View刷新自己。
	(3)AttachInfo是在View第一次attach到Window时，ViewRoot传给自己的子View的。这个AttachInfo之后，会顺着布局体系一直传递到最底层的View。
	(4)在invalidate中,调用父View的invalidateChild，这是一个从第向上回溯的过程，每一层的父View都将自己的显示区域与传入的刷新Rect做交集。这个向上回溯的过程直到ViewRoot那里结束，由ViewRoot对这个最终的刷新区域做刷新。
	
三十三 请描述安卓四大组建之间的关系，并说下安卓MVC的设计模式。 
	Android 的四大组件:Activity是界面，Service是服务，BroadcastReceive是广播，ContentProvider是数据库中的内空共享;
	他们之间最大的关系就是在Activity中通过Intent（意图）来传数据。
		
	安卓MVC的设计模式:
		MVC模式下，系统框架的类库被划分为3种：模型（Model）、视图（View）、控制器（Controller）。
		模型对象负责建立数据结构和相应的行为操作处理。视图对象负责在屏幕上渲染出相应的图形信息展示给用户看。
		控制器对象负责截获用户的按键和屏幕触摸等事件，协调Model对象和View对象。
			
		主要目的都是划分模块职责,降低模块耦合,易测试,提高代码复用
			
		用户与视图交互，视图接收并反馈用户的动作；视图把用户的请求传给相应的控制器，由控制器决定调用哪个模型，
		然后由模型调用相应的业务逻辑对用户请求进行加工处理，如果需要返回数据，模型会把相应的数据返回给控制器，
		由控制器调用相应的视图，最终由视图格式化和渲染返回的数据，对于返回的数据完全可以增加用户体验效果展现给用户。
　　	一个模型可以有多个视图，一个视图可以有多个控制器，一个控制器也可以有多个模型。

三十四 请解释安卓签名机制的意义？
	签名机制标明了APK的发行机构。因此，站在软件安全的角度，我们就可以通过比对APK的签名情况，判断此APK是否由“官方”发行，
	而不是被破解篡改过重新签名打包的“盗版软件”。
	意义：
		（1）应用程序升级：如果你希望用户无缝升级到新的版本，那么你必须用同一个证书进行签名。这是由于只有以同一个证书签名，
			系统才会允许安装升级的应用程序。如果你采用了不同的证书，那么系统会要求你的应用程序采用不同的包名称，
			在这种情况下相当于安装了一个全新的应用程序。如果想升级应用程序，签名证书要相同，包名称要相同！
		（2）应用程序模块化：Android系统可以允许同一个证书签名的多个应用程序在一个进程里运行，系统实际把他们作为一个单个的应用程序，
			此时就可以把我们的应用程序以模块的方式进行部署，而用户可以独立的升级其中的一个模块  
		（3）代码或者数据共享：Android提供了基于签名的权限机制，那么一个应用程序就可以为另一个以相同证书签名的应用程序公开自己的功能。
			以同一个证书对多个应用程序进行签名，利用基于签名的权限检查，你就可以在应用程序间以安全的方式共享代码和数据了。  
			
三十五 Android中实现对象序列化的方式有哪些？分别有什么优缺点
	（1）.Serializable
	特点：Serializable是JavaSe的接口，在序列化的时候会产生大量的临时变量，从而容易引起频繁的GC，性能比较低下。
	优点：可实现可持久化操作，方便保存，简单易用
	缺点：使用了反射，序列化的过程较慢
	（2）Parcelable
	 特点：这是Android中实现序列化的方式，使用起来比Serializable要麻烦点，效率比Serializable较高
	 优点：性能好，占用内存小，执行速度快
	 缺点：阅读性差，不易维护
	 
三十六 AIDL的全称是什么？如何工作？
	AIDL:Android Interface Definition Language,即Android接口定义语言。
		如何工作：
		1、创建AIDL文件,在这个文件里面定义接口,该接口定义了可供客户端访问的方法和属性。 
		2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.
		3、在Java文件中, 在Java文件中,实现AIDL中定义的接口.编译器会根据AIDL接口,产生一个JAVA接口
		4、向客户端提供接口ITaskBinder,如果写的是service，扩展该Service并重载onBind()方法来返回一个实现上述接口的类的实例。 
		5、在服务器端回调客户端的函数.前提是当客户端获取的IBinder接口的时候,要去注册回调函数,只有这样,服务器端才知道该调用那些函数 
		
三十七 Android进程和Linux的进程, 应用程序的进程是否为同一个概念
	DVM进程指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 
	中的一个进程，所以说可以认为是同一个概念。 Dalvik是Google公司自己设计用于Android平台的Java虚拟机,
	每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。
	
三十八 请描述一下Intent 和 Intent Filter
	Intent代表了Android应用的启动”意图”，Android应用将会根据Intent来启动指定组件。
		Intent是由Component组件名称、Action、Data、Category、Extra及Flag六部分组成的，
		1、component：用于标识唯一的应用程序组件，在Intent传递过程中，组件名称是一个可选项，当指定它时，便是显式的Intent消息，
			我们称为“显示意图”，当不指定它时，Android系统则会根据其他信息及IntentFilter的过滤条件选择相应的组件，我们称之为 “隐式意图
		2、Action实际上就是一个描述了Intent所触发动作名称的字符串
		3、Data主要是对Intent消息中数据的封装，主要描述Intent的动作所操作到的数据的URI及类型
		4、Category是对目标组件类别信息的描述
		5、Extra中封装了一些额外的附加信息，这些信息是以键值对的形式存在的。Intent可以通过putExtras()与getExtras()方法来存储和获取Extra。
		6、一些有关系统如何启动组件的标志位，Android同样对其进行了封装。
		
		IntentFilter实际上相当于Intent的过滤器，一个应用程序开发完成后，需要告诉Android系统自己能够处理哪些隐形的Intent请求，这就需要声明IntentFilter。
		IntentFilter过滤Intent时，一般是通过Action、Data及Category三方面进行监测的。
		1、检查Action：一个Intent只能设置一种Action，但是一个IntentFilter却可以设置多个Action过滤
		2、检查Data：数据的监测主要包含两部分，即数据的URI及数据类型，而数据URI又被分成三部分进行匹配（scheme、authority、path），只有这些全部匹配时，Data的验证才会成功。
		3、检查Category：IntentFilter同样可以设置多个Category，当Intent中的Category与IntentFilter中的一个Category完全匹配时，便会通过Category的检查，而其他的Category并不受影响。
		但是当IntentFilter没有设置Category时，只能与没有设置Category的Intent相匹配。
		
三十九 Intent传递数据时，可以传递哪些类型数据？
	Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。
	还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。
	
四十 谈谈UI中， Padding和Margin有什么区别？
	padding是控件的内容相对控件的边缘的边距．margin是控件边缘相对父空间的边距．